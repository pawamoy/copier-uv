# CLAUDE.md

This file provides guidance for AI assistants working on this codebase.

## Project Overview

**{{ project_name }}** - Python package managed with [uv](https://github.com/astral-sh/uv).

| Attribute | Value |
|-----------|-------|
| Package | `{{ python_package_distribution_name }}` |
| Import | `{{ python_package_import_name }}` |
{%- if python_package_command_line_name %}
| CLI | `{{ python_package_command_line_name }}` |
{%- endif %}
| Python | 3.12, 3.13, 3.14 |

## Quick Reference

```bash
make setup    # Install dependencies
make format   # Auto-format code
make check    # Run all quality checks
make test     # Run tests
make docs     # Serve docs locally
```

## Standard Workflow

1. **Explore** - Read relevant code first
2. **Plan** - Ask clarifying questions for architectural changes
3. **Test First** - Write failing test (TDD)
4. **Code** - Minimal code to pass test
5. **Refactor** - Clean up, keep tests green
6. **Verify** - `make format && make check && make test`

**Ask before:** Adding dependencies, changing public API, modifying structure.

## Clean Code (Uncle Bob)

### SOLID Principles

| Principle | Description |
|-----------|-------------|
| **S**ingle Responsibility | One reason to change |
| **O**pen/Closed | Open for extension, closed for modification |
| **L**iskov Substitution | Subtypes substitutable for base types |
| **I**nterface Segregation | Specific interfaces > general interfaces |
| **D**ependency Inversion | Depend on abstractions |

### Guidelines

- **Functions**: Small (<20 lines), do one thing, few args (0-2), no side effects
- **Classes**: Small, cohesive, encapsulated
- **General**: DRY, YAGNI, meaningful names, Boy Scout Rule

## TDD (Test-Driven Development)

**Uncle Bob's Three Laws:**
1. No production code without a failing test
2. Write only enough test to fail
3. Write only enough code to pass

**Cycle:** ğŸ”´ Red â†’ ğŸŸ¢ Green â†’ ğŸ”µ Refactor â†’ Repeat

**Test behavior, not implementation.** Tests verify *what* code does, not *how*.

**FIRST:** **F**ast, **I**ndependent, **R**epeatable, **S**elf-validating, **T**imely

## Code Style

### Required in Every File

```python
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Sequence
```

### Type Hints (Mandatory)

Every function, method, and variable MUST have type hints.

### Docstrings (Google Style)

```python
def calculate(prices: list[float], *, tax: float = 0.0) -> float:
    """Calculate total with tax.

    Parameters:
        prices: Item prices.
        tax: Tax rate as decimal.

    Returns:
        Final total.
    """
```

### Ruff Config

- Line length: 120
- Target: Python 3.12+
- Docstrings: Google convention
- Imports: Absolute only

## Commit Messages

**Format:** `<type>[(scope)]: Subject`

**Types:** `feat`, `fix`, `docs`, `style`, `refactor`, `perf`, `test`, `build`, `ci`, `chore`, `deps`

**Examples:**
```
feat: Add user authentication
fix(parser): Handle empty input
```

**Changelog types:** `build`, `deps`, `feat`, `fix`, `refactor`

## Project Structure

```
{{ repository_name }}/
â”œâ”€â”€ src/{{ python_package_import_name }}/
â”‚   â”œâ”€â”€ __init__.py       # Public API
â”‚   â””â”€â”€ _internal/        # Private implementation
â”œâ”€â”€ tests/
â”œâ”€â”€ docs/
â”œâ”€â”€ config/               # Tool configs (ruff, mypy, pytest)
{%- if include_notebooks %}
â”œâ”€â”€ notebooks/            # Marimo notebooks
{%- endif %}
â”œâ”€â”€ pyproject.toml
â””â”€â”€ duties.py             # Task definitions
```

- **Public API**: Exports in `__init__.py`
- **Internal**: `_internal/` - not for external use
{% if include_notebooks %}
## Notebooks

**Do not run marimo notebooks directly.** Provide the command to the user instead.

```bash
uv run marimo edit notebooks/starter.py           # Edit
uv run marimo edit --sandbox --watch notebooks/   # Edit with flags
uv run marimo run notebooks/starter.py            # Run as app
```
{% endif %}
## Logging

Import `logger` directly from loguru (it's a singleton):

```python
from loguru import logger

logger.info("Action", user_id=123, action="login")  # Structured data as kwargs
```

Use `configure_logging` from `_internal.logging` only to set up handlers.
Example: `configure_logging(level="INFO", json_logs=False)`

## Key Files

| File | Purpose |
|------|---------|
| `pyproject.toml` | Metadata, dependencies |
| `duties.py` | Task definitions |
| `config/ruff.toml` | Linting rules |
| `config/mypy.ini` | Type checking |

## Do's and Don'ts

**DO:**
- âœ… Write tests FIRST (TDD)
- âœ… Keep changes small and modular
- âœ… Test behavior, not implementation
- âœ… Type hints on everything
- âœ… Google-style docstrings
- âœ… `from __future__ import annotations` in every file
- âœ… Absolute imports only
- âœ… Run `make format && make check && make test`

**DON'T:**
- âŒ Production code without failing test
- âŒ Test implementation details
- âŒ Push/release/deploy (user handles)
- âŒ Skip type hints
- âŒ Relative imports
- âŒ `print()` for debugging (use `logger`)
- âŒ `print()` for logging (use `logger`)
